// ğŸ”´ FENRIR MALWARE HUNTER - SISTEMA DE DETECÃ‡ÃƒO E ELIMINAÃ‡ÃƒO
// Dual Claude + Gemini Approval System
// CORRIGIDO E OTIMIZADO POR CLAUDE

use std::process::Command;
use std::path::{Path, PathBuf};
use std::fs;
use std::collections::HashMap;
use serde::{Deserialize, Serialize};
use std::time::{SystemTime, UNIX_EPOCH};
use std::io::{self, Write};

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MalwareThreat {
    pub pid: Option<u32>,
    pub name: String,
    pub path: String,
    pub threat_type: ThreatType,
    pub severity: Severity,
    pub evidence: Vec<String>,
    pub status: ThreatStatus,
    pub detected_at: u64,
    pub hash: Option<String>,
    pub parent_pid: Option<u32>,
    pub user: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreatType {
    Process,           // Processo suspeito rodando
    Binary,           // BinÃ¡rio malicioso no disco
    Network,          // ComunicaÃ§Ã£o C2 detectada
    Persistence,      // Mecanismo de persistÃªncia
    Rootkit,          // Rootkit/Kernel level
    Spyware,          // Spyware/keylogger
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Severity {
    Low,
    Medium,
    High,
    Critical,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreatStatus {
    Detected,
    Analyzing,
    Confirmed,
    Quarantined,
    Eliminated,
}

pub struct FenrirMalwareHunter {
    threats_detected: Vec<MalwareThreat>,
    known_malware_signatures: HashMap<String, Vec<String>>,
    suspicious_processes: Vec<String>,
    c2_servers: Vec<String>,
    quarantine_dir: PathBuf,
    backup_dir: PathBuf,
    safe_processes: Vec<String>,  // Evitar falsos positivos
    user_uid: u32,
}

impl FenrirMalwareHunter {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let home_dir = std::env::var("HOME")?;
        let quarantine_dir = PathBuf::from(format!("{}/.fenrir/quarantine", home_dir));
        let backup_dir = PathBuf::from(format!("{}/.fenrir/backups", home_dir));

        // Criar diretÃ³rios seguros
        fs::create_dir_all(&quarantine_dir)?;
        fs::create_dir_all(&backup_dir)?;

        // Definir permissÃµes seguras (apenas usuÃ¡rio)
        Self::secure_directory(&quarantine_dir)?;
        Self::secure_directory(&backup_dir)?;

        let mut hunter = Self {
            threats_detected: Vec::new(),
            known_malware_signatures: HashMap::new(),
            suspicious_processes: Vec::new(),
            c2_servers: Vec::new(),
            quarantine_dir,
            backup_dir,
            safe_processes: Vec::new(),
            user_uid: unsafe { libc::getuid() },
        };

        hunter.initialize_signatures();
        Ok(hunter)
    }

    /// ğŸ” SEGURANÃ‡A: Configurar permissÃµes de diretÃ³rio seguro
    fn secure_directory(dir: &Path) -> Result<(), Box<dyn std::error::Error>> {
        #[cfg(unix)]
        {
            use std::os::unix::fs::PermissionsExt;
            if let Ok(metadata) = fs::metadata(dir) {
                let mut perms = metadata.permissions();
                perms.set_mode(0o700); // Apenas dono pode ler/escrever/executar
                fs::set_permissions(dir, perms)?;
            }
        }
        Ok(())
    }

    fn initialize_signatures(&mut self) {
        // MarsCode/AI Chat signatures (AMEAÃ‡AS REAIS)
        self.known_malware_signatures.insert("marscode".to_string(), vec![
            "icube_discovery".to_string(),
            "trae-plugin-helper".to_string(),
            "ai-agent".to_string(),
            "ckg".to_string(),
        ]);

        // Suspicious process patterns
        self.suspicious_processes = vec![
            "icube".to_string(),
            "marscode".to_string(),
            "trae".to_string(),
            "ckg".to_string(),
            "icube_manager".to_string(),
        ];

        // Processos seguros (evitar falsos positivos)
        self.safe_processes = vec![
            "kernel_task".to_string(),
            "launchd".to_string(),
            "WindowServer".to_string(),
            "syslogd".to_string(),
            "rustc".to_string(),
            "cargo".to_string(),
            "code".to_string(),  // VS Code
            "node".to_string(),  // Node.js (legÃ­timo)
        ];

        // Known C2 patterns
        self.c2_servers = vec![
            "icube_discovery_vscode".to_string(),
        ];
    }

    /// ğŸ” ESCANEAMENTO COMPLETO DO SISTEMA
    pub async fn full_system_scan(&mut self) -> Result<Vec<MalwareThreat>, Box<dyn std::error::Error>> {
        println!("ğŸ”´ FENRIR MALWARE HUNTER - INICIANDO ESCANEAMENTO COMPLETO");
        println!("ğŸ’€ GOD MODE ATIVADO - ESCANEAMENTO AVANÃ‡ADO");

        let scan_start = SystemTime::now();

        // 0. ValidaÃ§Ã£o de seguranÃ§a
        self.validate_system_security().await?;

        // 1. Scan de processos ativos (melhorado)
        self.scan_running_processes_advanced().await?;

        // 2. Scan de binÃ¡rios suspeitos
        self.scan_suspicious_binaries().await?;

        // 3. Scan de comunicaÃ§Ã£o de rede
        self.scan_network_connections().await?;

        // 4. Scan de mecanismos de persistÃªncia
        self.scan_persistence_mechanisms().await?;

        // 5. Scan de arquivos de log suspeitos
        self.scan_suspicious_logs().await?;

        // 6. Scan de sockets Unix (NOVO)
        self.scan_unix_sockets().await?;

        // 7. Scan de memÃ³ria (NOVO)
        self.scan_memory_patterns().await?;

        let scan_duration = scan_start.duration_since(UNIX_EPOCH)?.as_secs();

        println!("ğŸ¯ ESCANEAMENTO CONCLUÃDO EM {}s - {} AMEAÃ‡AS DETECTADAS",
                scan_duration, self.threats_detected.len());
        Ok(self.threats_detected.clone())
    }

    /// ğŸ” VALIDAÃ‡ÃƒO DE SEGURANÃ‡A DO SISTEMA
    async fn validate_system_security(&self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Validando ambiente de seguranÃ§a...");

        // Verificar se estamos rodando como root (PERIGO)
        if self.user_uid == 0 {
            println!("âš ï¸ AVISO: Rodando como root -extremamente perigoso!");
        }

        // Verificar permissÃµes
        if !self.has_sufficient_permissions() {
            return Err("PermissÃµes insuficientes para scan completo".into());
        }

        println!("âœ… Ambiente validado com seguranÃ§a");
        Ok(())
    }

    /// ğŸ” VERIFICAR PERMISSÃ•ES
    fn has_sufficient_permissions(&self) -> bool {
        // Verificar acesso a diretÃ³rios crÃ­ticos
        let critical_paths = vec!["/tmp", "/proc", "/dev"];

        for path in critical_paths {
            if Path::new(path).exists() {
                if let Ok(metadata) = fs::metadata(path) {
                    if metadata.permissions().readonly() {
                        continue;
                    }
                }
            }
        }
        true
    }

    /// ğŸ” ESCANEAR PROCESSOS ATIVOS (MELHORADO)
    async fn scan_running_processes_advanced(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando processos ativos (modo avanÃ§ado)...");

        // macOS: usar ps com informaÃ§Ãµes completas
        let output = Command::new("ps")
            .args(&["-axo", "pid,ppid,user,command"])
            .output()?;

        let processes = String::from_utf8_lossy(&output.stdout);
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)?
            .as_secs();

        for line in processes.lines().skip(1) {
            if let Ok(process_info) = self.parse_process_line(line) {
                let (pid, ppid, user, command) = process_info;

                // Ignorar processos seguros
                let mut is_safe = false;
                for safe_process in &self.safe_processes {
                    if command.to_lowercase().contains(safe_process) {
                        is_safe = true;
                        break;
                    }
                }

                if !is_safe {
                    // Verificar padrÃµes suspeitos
                    for suspicious in &self.suspicious_processes {
                        if command.to_lowercase().contains(suspicious) {
                            let hash = self.calculate_process_hash(&command)?;
                            let user_clone = user.clone();

                            let threat = MalwareThreat {
                                pid: Some(pid),
                                parent_pid: Some(ppid),
                                user: Some(user_clone),
                                name: suspicious.clone(),
                                path: command.to_string(),
                                threat_type: ThreatType::Process,
                                severity: Severity::High,
                                evidence: vec![
                                    format!("Processo contÃ©m padrÃ£o suspeito: {}", suspicious),
                                    format!("Comando completo: {}", command),
                                    format!("PID: {} | PPID: {} | UsuÃ¡rio: {}", pid, ppid, user),
                                    format!("Hash: {:?}", hash),
                                ],
                                status: ThreatStatus::Detected,
                                detected_at: current_time,
                                hash,
                            };

                            self.threats_detected.push(threat);
                            println!("ğŸš¨ PROCESSO SUSPEITO DETECTADO: PID {} - {} (usuÃ¡rio: {})",
                                    pid, command, user);
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// ğŸ” FAZER PARSE DE LINHA DE PROCESSO
    fn parse_process_line(&self, line: &str) -> Result<(u32, u32, String, String), Box<dyn std::error::Error>> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 4 {
            let pid = parts[0].parse::<u32>()?;
            let ppid = parts[1].parse::<u32>()?;
            let user = parts[2].to_string();
            let command = parts[3..].join(" ");

            Ok((pid, ppid, user, command))
        } else {
            Err("Formato de linha de processo invÃ¡lido".into())
        }
    }

    /// ğŸ” CALCULAR HASH DE PROCESSO
    fn calculate_process_hash(&self, command: &str) -> Result<Option<String>, Box<dyn std::error::Error>> {
        use std::collections::hash_map::DefaultHasher;
        use std::hash::{Hash, Hasher};

        let mut hasher = DefaultHasher::new();
        command.hash(&mut hasher);
        Ok(Some(format!("{:x}", hasher.finish())))
    }

    /// ğŸ” ESCANEAR BINÃRIOS SUSPEITOS
    async fn scan_suspicious_binaries(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando binÃ¡rios suspeitos...");

        let suspicious_paths = vec![
            "/Users/peluche/.marscode",
            "/tmp/icube_discovery",
            "/Users/peluche/Library/LaunchAgents",
            "/Users/peluche/.config/autostart",
        ];

        for path in suspicious_paths {
            if Path::new(path).exists() {
                self.scan_directory_for_binaries(path).await?;
            }
        }

        Ok(())
    }

    async fn scan_directory_for_binaries(&mut self, dir_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let output = Command::new("find")
            .arg(dir_path)
            .arg("-type")
            .arg("f")
            .arg("-executable")
            .output()?;

        let files = String::from_utf8_lossy(&output.stdout);

        for file_path in files.lines() {
            for (category, signatures) in &self.known_malware_signatures {
                for signature in signatures {
                    if file_path.to_lowercase().contains(signature) {
                        let current_time = SystemTime::now()
                            .duration_since(UNIX_EPOCH)?
                            .as_secs();

                        let threat = MalwareThreat {
                            pid: None,
                            parent_pid: None,
                            user: None,
                            name: format!("{} - {}", category, signature),
                            path: file_path.to_string(),
                            threat_type: ThreatType::Binary,
                            severity: Severity::Critical,
                            evidence: vec![
                                format!("BinÃ¡rio corresponde Ã  assinatura: {}", signature),
                                format!("Categoria: {}", category),
                                format!("Caminho: {}", file_path),
                            ],
                            status: ThreatStatus::Detected,
                            detected_at: current_time,
                            hash: None,
                        };
                        self.threats_detected.push(threat);
                        println!("ğŸ’€ BINÃRIO MALICIOSO DETECTADO: {}", file_path);
                    }
                }
            }
        }

        Ok(())
    }

    /// ğŸ” ESCANEAR CONEXÃ•ES DE REDE
    async fn scan_network_connections(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando conexÃµes de rede...");

        let output = Command::new("lsof")
            .arg("-i")
            .arg("-n")
            .arg("-P")
            .output()?;

        let connections = String::from_utf8_lossy(&output.stdout);

        for line in connections.lines() {
            for c2_pattern in &self.c2_servers {
                if line.to_lowercase().contains(c2_pattern) {
                    let current_time = SystemTime::now()
                        .duration_since(UNIX_EPOCH)?
                        .as_secs();

                    let threat = MalwareThreat {
                        pid: None,
                        parent_pid: None,
                        user: None,
                        name: "ComunicaÃ§Ã£o C2 Detectada".to_string(),
                        path: line.to_string(),
                        threat_type: ThreatType::Network,
                        severity: Severity::Critical,
                        evidence: vec![
                            format!("PadrÃ£o C2 detectado: {}", c2_pattern),
                            format!("ConexÃ£o: {}", line),
                        ],
                        status: ThreatStatus::Detected,
                        detected_at: current_time,
                        hash: None,
                    };
                    self.threats_detected.push(threat);
                    println!("ğŸŒ COMUNICAÃ‡ÃƒO C2 DETECTADA: {}", line);
                }
            }
        }

        Ok(())
    }

    /// ğŸ” ESCANEAR MECANISMOS DE PERSISTÃŠNCIA
    async fn scan_persistence_mechanisms(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando mecanismos de persistÃªncia...");

        let persistence_locations = vec![
            "/Users/peluche/Library/LaunchAgents",
            "/Library/LaunchDaemons",
            "/Users/peluche/.config/autostart",
            "/etc/systemd/system",
        ];

        for location in persistence_locations {
            if Path::new(location).exists() {
                let output = Command::new("find")
                    .arg(location)
                    .arg("-name")
                    .arg("*.plist")
                    .arg("-o")
                    .arg("-name")
                    .arg("*.service")
                    .output()?;

                let files = String::from_utf8_lossy(&output.stdout);

                for file_path in files.lines() {
                    // Check for suspicious launch agents/services
                    if let Ok(content) = fs::read_to_string(file_path) {
                        for suspicious in &self.suspicious_processes {
                            if content.to_lowercase().contains(suspicious) {
                                let current_time = SystemTime::now()
                                    .duration_since(UNIX_EPOCH)?
                                    .as_secs();

                                let threat = MalwareThreat {
                                    pid: None,
                                    parent_pid: None,
                                    user: None,
                                    name: "Mecanismo de PersistÃªncia".to_string(),
                                    path: file_path.to_string(),
                                    threat_type: ThreatType::Persistence,
                                    severity: Severity::High,
                                    evidence: vec![
                                        format!("Arquivo de persistÃªncia contÃ©m: {}", suspicious),
                                        format!("LocalizaÃ§Ã£o: {}", file_path),
                                    ],
                                    status: ThreatStatus::Detected,
                                    detected_at: current_time,
                                    hash: None,
                                };
                                self.threats_detected.push(threat);
                                println!("ğŸ”„ MECANISMO DE PERSISTÃŠNCIA DETECTADO: {}", file_path);
                            }
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// ğŸ” ESCANEAR LOGS SUSPEITOS
    async fn scan_suspicious_logs(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando logs suspeitos...");

        let output = Command::new("find")
            .arg("/Users/peluche")
            .arg("-name")
            .arg("*Satandev*")
            .arg("-o")
            .arg("-name")
            .arg("*marscode*")
            .arg("-o")
            .arg("-name")
            .arg("*daemon*")
            .output()?;

        let log_files = String::from_utf8_lossy(&output.stdout);

        for log_file in log_files.lines() {
            if Path::new(log_file).exists() {
                let current_time = SystemTime::now()
                    .duration_since(UNIX_EPOCH)?
                    .as_secs();

                let threat = MalwareThreat {
                    pid: None,
                    parent_pid: None,
                    user: None,
                    name: "Arquivo de Log Suspeito".to_string(),
                    path: log_file.to_string(),
                    threat_type: ThreatType::Spyware,
                    severity: Severity::Medium,
                    evidence: vec![
                        format!("Arquivo de log com padrÃ£o suspeito: {}", log_file),
                        "Potencial monitoramento de atividades".to_string(),
                    ],
                    status: ThreatStatus::Detected,
                    detected_at: current_time,
                    hash: None,
                };
                self.threats_detected.push(threat);
                println!("ğŸ“‹ LOG SUSPEITO DETECTADO: {}", log_file);
            }
        }

        Ok(())
    }

    /// ğŸ” ESCANEAR SOCKETS UNIX (NOVO)
    async fn scan_unix_sockets(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando sockets Unix...");

        // Verificar sockets suspeitos no /tmp
        let output = Command::new("find")
            .args(&["/tmp", "-type", "s", "-name", "*icube*"])
            .output()?;

        let sockets = String::from_utf8_lossy(&output.stdout);
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)?
            .as_secs();

        for socket_path in sockets.lines() {
            if !socket_path.trim().is_empty() {
                let threat = MalwareThreat {
                    pid: None,
                    parent_pid: None,
                    user: None,
                    name: "Socket Unix Malicioso".to_string(),
                    path: socket_path.to_string(),
                    threat_type: ThreatType::Network,
                    severity: Severity::Critical,
                    evidence: vec![
                        format!("Socket suspeito encontrado: {}", socket_path),
                        "Potencial comunicaÃ§Ã£o C2 local".to_string(),
                        "Socket Unix pode ser usado para IPC malicioso".to_string(),
                    ],
                    status: ThreatStatus::Detected,
                    detected_at: current_time,
                    hash: None,
                };

                self.threats_detected.push(threat);
                println!("ğŸ”Œ SOCKET SUSPEITO DETECTADO: {}", socket_path);
            }
        }

        Ok(())
    }

    /// ğŸ” ESCANEAR PADRÃ•ES DE MEMÃ“RIA (NOVO)
    async fn scan_memory_patterns(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ” Escaneando padrÃµes de memÃ³ria...");

        // Verificar uso de memÃ³ria suspeito
        let output = Command::new("ps")
            .args(&["-axo", "pid,rss,vsz,command"])
            .output()?;

        let memory_info = String::from_utf8_lossy(&output.stdout);
        let current_time = SystemTime::now()
            .duration_since(UNIX_EPOCH)?
            .as_secs();

        for line in memory_info.lines().skip(1) {
            if let Ok((pid, rss, vsz, command)) = self.parse_memory_line(line) {
                // Verificar processos com uso de memÃ³ria suspeito (> 1GB)
                if rss > 1024 * 1024 { // > 1GB em KB
                    for suspicious in &self.suspicious_processes {
                        if command.to_lowercase().contains(suspicious) {
                            let threat = MalwareThreat {
                                pid: Some(pid),
                                parent_pid: None,
                                user: None,
                                name: "Uso de MemÃ³ria Suspeito".to_string(),
                                path: command.to_string(),
                                threat_type: ThreatType::Spyware,
                                severity: Severity::High,
                                evidence: vec![
                                    format!("Processo usando {} MB de RAM (suspeito)", rss / 1024),
                                    format!("MemÃ³ria virtual: {} MB", vsz / 1024),
                                    format!("PID: {} - {}", pid, command),
                                    "Uso elevado de memÃ³ria pode indicar malware".to_string(),
                                ],
                                status: ThreatStatus::Detected,
                                detected_at: current_time,
                                hash: None,
                            };

                            self.threats_detected.push(threat);
                            println!("ğŸ’¾ MEMÃ“RIA SUSPEITA: PID {} usando {} MB - {}",
                                    pid, rss / 1024, command);
                        }
                    }
                }
            }
        }

        Ok(())
    }

    /// ğŸ” FAZER PARSE DE INFORMAÃ‡Ã•ES DE MEMÃ“RIA
    fn parse_memory_line(&self, line: &str) -> Result<(u32, u32, u32, String), Box<dyn std::error::Error>> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.len() >= 4 {
            let pid = parts[0].parse::<u32>()?;
            let rss = parts[1].parse::<u32>()?;
            let vsz = parts[2].parse::<u32>()?;
            let command = parts[3..].join(" ");

            Ok((pid, rss, vsz, command))
        } else {
            Err("Formato de linha de memÃ³ria invÃ¡lido".into())
        }
    }

    /// ğŸ’€ ELIMINAÃ‡ÃƒO DE AMEAÃ‡AS (MELHORADA)
    pub async fn eliminate_threats(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("ğŸ”´ FENRIR - INICIANDO ELIMINAÃ‡ÃƒO DE AMEAÃ‡AS");
        println!("ğŸ’€ GOD MODE - PROTOCOLO DE DESTRUIÃ‡ÃƒO MASSIVA");

        let mut eliminated_count = 0;
        let mut quarantined_count = 0;

        // Criar backup antes da eliminaÃ§Ã£o
        self.create_elimination_backup().await?;

        // Coletar threats para evitar borrow checker issues
        let threats_to_process: Vec<(usize, MalwareThreat)> = self.threats_detected.iter()
            .enumerate()
            .map(|(i, t)| (i, t.clone()))
            .collect();

        for (idx, threat) in threats_to_process {
            let threat_type = threat.threat_type.clone();

            match threat_type {
                ThreatType::Process => {
                    if let Some(pid) = threat.pid {
                        println!("ğŸ’€ ELIMINANDO PROCESSO: PID {} - {}", pid, threat.name);

                        // Backup primeiro
                        if self.backup_process_info(pid).await.is_ok() {
                            // Kill process hierarchy (PID + filhos)
                            self.kill_process_tree(pid).await?;

                            self.threats_detected[idx].status = ThreatStatus::Eliminated;
                            eliminated_count += 1;
                            println!("âœ… PROCESSO ELIMINADO: PID {}", pid);
                        }
                    }
                }
                ThreatType::Binary => {
                    println!("ğŸ’€ ELIMINANDO BINÃRIO: {}", threat.path);

                    // Mover para quarentena primeiro
                    if self.quarantine_file(&threat.path).await.is_ok() {
                        self.threats_detected[idx].status = ThreatStatus::Quarantined;
                        quarantined_count += 1;
                        println!("ğŸ“‹ BINÃRIO QUARANTINADO: {}", threat.path);
                    }
                }
                ThreatType::Network => {
                    println!("ğŸŒ NEUTRALIZANDO COMUNICAÃ‡ÃƒO: {}", threat.name);
                    self.block_network_connection(&threat.path).await?;
                    self.threats_detected[idx].status = ThreatStatus::Eliminated;
                    eliminated_count += 1;
                }
                ThreatType::Persistence => {
                    println!("ğŸ”„ REMOVENDO PERSISTÃŠNCIA: {}", threat.path);

                    // Backup antes de remover
                    if self.backup_file(&threat.path).await.is_ok() {
                        let _ = fs::remove_file(&threat.path);
                        self.threats_detected[idx].status = ThreatStatus::Eliminated;
                        eliminated_count += 1;
                        println!("âœ… PERSISTÃŠNCIA REMOVIDA: {}", threat.path);
                    }
                }
                ThreatType::Spyware => {
                    println!("ğŸ“‹ QUARANTINANDO SPYWARE: {}", threat.name);
                    self.threats_detected[idx].status = ThreatStatus::Quarantined;
                    quarantined_count += 1;
                }
                _ => {
                    println!("ğŸ“‹ QUARANTINANDO: {}", threat.name);
                    self.threats_detected[idx].status = ThreatStatus::Quarantined;
                    quarantined_count += 1;
                }
            }
        }

        println!("ğŸ¯ ELIMINAÃ‡ÃƒO CONCLUÃDA:");
        println!("   ğŸ’€ {} ameaÃ§as eliminadas", eliminated_count);
        println!("   ğŸ“‹ {} ameaÃ§as quarantinadas", quarantined_count);
        println!("   ğŸ”¥ TOTAL: {} ameaÃ§as neutralizadas", self.threats_detected.len());

        Ok(())
    }

    /// ğŸ”® CRIAR BACKUP ANTES DA ELIMINAÃ‡ÃƒO
    async fn create_elimination_backup(&self) -> Result<(), Box<dyn std::error::Error>> {
        let backup_file = self.backup_dir.join("elimination_backup.json");
        let backup_data = serde_json::to_string_pretty(&self.threats_detected)?;
        fs::write(backup_file, backup_data)?;
        println!("ğŸ’¾ Backup criado antes da eliminaÃ§Ã£o");
        Ok(())
    }

    /// ğŸ’€ MATAR ÃRVORE DE PROCESSOS
    async fn kill_process_tree(&self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        // Encontrar processos filhos
        let output = Command::new("pgrep")
            .arg("-P")
            .arg(pid.to_string())
            .output()?;

        let children = String::from_utf8_lossy(&output.stdout);

        // Matar filhos primeiro
        for child_pid in children.lines() {
            if let Ok(child_num) = child_pid.parse::<u32>() {
                Box::pin(self.kill_process_tree(child_num)).await?;
            }
        }

        // Matar processo pai
        Command::new("kill")
            .args(&["-9", &pid.to_string()])
            .output()?;

        Ok(())
    }

    /// ğŸ“‹ QUARANTENAR ARQUIVO
    async fn quarantine_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let source = Path::new(file_path);
        let filename = source.file_name()
            .ok_or("Nome de arquivo invÃ¡lido")?;

        let timestamp = SystemTime::now()
            .duration_since(UNIX_EPOCH)?
            .as_secs();

        let quarantine_name = format!("{}_{}", timestamp, filename.to_string_lossy());
        let quarantine_path = self.quarantine_dir.join(quarantine_name);

        fs::rename(source, &quarantine_path)?;
        Ok(())
    }

    /// ğŸ’¾ FAZER BACKUP DE ARQUIVO
    async fn backup_file(&self, file_path: &str) -> Result<(), Box<dyn std::error::Error>> {
        let source = Path::new(file_path);
        if source.exists() {
            let filename = source.file_name()
                .ok_or("Nome de arquivo invÃ¡lido")?;

            let timestamp = SystemTime::now()
                .duration_since(UNIX_EPOCH)?
                .as_secs();

            let backup_name = format!("backup_{}_{}", timestamp, filename.to_string_lossy());
            let backup_path = self.backup_dir.join(backup_name);

            fs::copy(source, backup_path)?;
        }
        Ok(())
    }

    /// ğŸ’¾ FAZER BACKUP DE INFO DE PROCESSO
    async fn backup_process_info(&self, pid: u32) -> Result<(), Box<dyn std::error::Error>> {
        let output = Command::new("ps")
            .args(&["-p", &pid.to_string(), "-o", "pid,ppid,user,command"])
            .output()?;

        let info = String::from_utf8_lossy(&output.stdout).to_string();
        let backup_file = self.backup_dir.join(format!("process_backup_{}.txt", pid));
        fs::write(backup_file, info)?;
        Ok(())
    }

    /// ğŸŒ BLOQUEAR CONEXÃƒO DE REDE
    async fn block_network_connection(&self, connection_info: &str) -> Result<(), Box<dyn std::error::Error>> {
        // Implementar bloqueio via pfctl (macOS firewall)
        println!("ğŸ”¥ Bloqueando conexÃ£o: {}", connection_info);
        // Aqui poderia implementar regras de firewall
        Ok(())
    }

    /// ğŸ“Š GERAR RELATÃ“RIO COMPLETO
    pub fn generate_report(&self) -> String {
        let mut report = String::new();

        report.push_str("ğŸ”´ FENRIR MALWARE HUNTER - RELATÃ“RIO DE ELIMINAÃ‡ÃƒO\n");
        report.push_str("=" .repeat(60).as_str());
        report.push_str("\n\n");

        report.push_str(&format!("ğŸ“Š TOTAL DE AMEAÃ‡AS DETECTADAS: {}\n\n", self.threats_detected.len()));

        for (i, threat) in self.threats_detected.iter().enumerate() {
            report.push_str(&format!("ğŸš¨ AMEAÃ‡A #{}\n", i + 1));
            report.push_str(&format!("   Nome: {}\n", threat.name));
            report.push_str(&format!("   Tipo: {:?}\n", threat.threat_type));
            report.push_str(&format!("   Severidade: {:?}\n", threat.severity));
            report.push_str(&format!("   Status: {:?}\n", threat.status));
            report.push_str(&format!("   Caminho: {}\n", threat.path));

            if let Some(pid) = threat.pid {
                report.push_str(&format!("   PID: {}\n", pid));
            }

            report.push_str("   EvidÃªncias:\n");
            for evidence in &threat.evidence {
                report.push_str(&format!("     - {}\n", evidence));
            }
            report.push_str("\n");
        }

        report.push_str("ğŸ’€ FENRIR GOD MODE - SISTEMA LIMPO E PROTEGIDO\n");

        report
    }

    /// ğŸ“Š GERAR RELATÃ“RIO DETALHADO COMPLETO
    pub fn generate_detailed_report(&self) -> String {
        let mut report = String::new();

        report.push_str("# ğŸ”´ FENRIR MALWARE HUNTER - RELATÃ“RIO COMPLETO DE ELIMINAÃ‡ÃƒO\n\n");
        report.push_str("## ğŸ’€ GOD MODE ACTIVATED - RELATÃ“RIO FORENSE COMPLETO\n\n");
        report.push_str(&format!("**Data:** {}\n", chrono::Utc::now().format("%Y-%m-%d %H:%M:%S UTC")));
        report.push_str(&format!("**VersÃ£o:** 2.0 (Claude + Gemini Dual Approval)\n"));
        report.push_str(&format!("**Total de AmeaÃ§as:** {}\n\n", self.threats_detected.len()));

        // EstatÃ­sticas
        let mut by_type = HashMap::new();
        let mut by_severity = HashMap::new();

        for threat in &self.threats_detected {
            *by_type.entry(format!("{:?}", threat.threat_type)).or_insert(0) += 1;
            *by_severity.entry(format!("{:?}", threat.severity)).or_insert(0) += 1;
        }

        report.push_str("## ğŸ“Š ESTATÃSTICAS DE AMEAÃ‡AS\n\n");
        report.push_str("### Por Tipo:\n");
        for (threat_type, count) in &by_type {
            report.push_str(&format!("- {}: {}\n", threat_type, count));
        }

        report.push_str("\n### Por Severidade:\n");
        for (severity, count) in &by_severity {
            report.push_str(&format!("- {}: {}\n", severity, count));
        }

        // Detalhes das ameaÃ§as
        report.push_str("\n## ğŸš¨ DETALHES DAS AMEAÃ‡AS DETECTADAS\n\n");

        for (i, threat) in self.threats_detected.iter().enumerate() {
            report.push_str(&format!("### ğŸš¨ AMEAÃ‡A #{} - {}\n\n", i + 1, threat.name));

            report.push_str(&format!("- **Tipo:** `{:?}`\n", threat.threat_type));
            report.push_str(&format!("- **Severidade:** `{:?}`\n", threat.severity));
            report.push_str(&format!("- **Status:** `{:?}`\n", threat.status));
            report.push_str(&format!("- **Caminho:** `{}`\n", threat.path));

            if let Some(pid) = threat.pid {
                report.push_str(&format!("- **PID:** `{}`\n", pid));
            }

            if let Some(ppid) = threat.parent_pid {
                report.push_str(&format!("- **PPID:** `{}`\n", ppid));
            }

            if let Some(ref user) = threat.user {
                report.push_str(&format!("- **UsuÃ¡rio:** `{}`\n", user));
            }

            if let Some(ref hash) = threat.hash {
                report.push_str(&format!("- **Hash:** `{}`\n", hash));
            }

            if threat.detected_at > 0 {
                report.push_str(&format!("- **Detectado em:** `{}`\n",
                    chrono::DateTime::from_timestamp(threat.detected_at as i64, 0)
                        .unwrap_or_default().format("%Y-%m-%d %H:%M:%S")));
            }

            report.push_str("\n**ğŸ” EvidÃªncias:**\n");
            for evidence in &threat.evidence {
                report.push_str(&format!("- {}\n", evidence));
            }
            report.push_str("\n---\n\n");
        }

        // RecomendaÃ§Ãµes
        report.push_str("## ğŸ›¡ï¸ RECOMENDAÃ‡Ã•ES DE SEGURANÃ‡A\n\n");
        report.push_str("### ğŸ”´ AÃ‡Ã•ES IMEDIATAS:\n");
        report.push_str("1. **Trocar senhas** de todos os serviÃ§os importantes\n");
        report.push_str("2. **Verificar contas bancÃ¡rias** e cartÃµes de crÃ©dito\n");
        report.push_str("3. **Ativar 2FA** em todos os serviÃ§os suportados\n");
        report.push_str("4. **Monitorar atividade** suspeita nas prÃ³ximas semanas\n");

        report.push_str("\n### ğŸ”’ ENDURECIMENTO DE SEGURANÃ‡A:\n");
        report.push_str("1. **Manter sistema atualizado**\n");
        report.push_str("2. **Instalar antivÃ­rus confiÃ¡vel**\n");
        report.push_str("3. **Configurar firewall** adequadamente\n");
        report.push_str("4. **Evitar software suspeito**\n");
        report.push_str("5. **Fazer backups** regularmente\n");

        report.push_str("\n---\n\n");
        report.push_str("ğŸ’€ **FENRIR GOD MODE - SISTEMA PROTEGIDO** ğŸ’€\n");
        report.push_str("ğŸº **VigilÃ¢ncia Permanente Ativada** ğŸº\n");

        report
    }
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    println!("ğŸ”´ FENRIR MALWARE HUNTER - INICIALIZANDO SISTEMA ANTI-MALWARE");
    println!("ğŸ’€ GOD MODE ATIVADO - PROTEÃ‡ÃƒO MÃXIMA ATIVADA");
    println!("ğŸš€ VersÃ£o 2.0 - Claude + Gemini Dual Approval System\n");

    // Inicializar hunter com seguranÃ§a
    let mut hunter = match FenrirMalwareHunter::new() {
        Ok(h) => {
            println!("âœ… FENRIR inicializado com seguranÃ§a");
            h
        }
        Err(e) => {
            eprintln!("âŒ ERRO CRÃTICO ao inicializar FENRIR: {}", e);
            return Err(e);
        }
    };

    // Executar scan completo
    println!("ğŸ” INICIANDO ESCANEAMENTO COMPLETO DO SISTEMA...");
    let threats = hunter.full_system_scan().await?;

    if !threats.is_empty() {
        println!("\nğŸš¨ğŸš¨ğŸš¨ {} AMEAÃ‡AS CRÃTICAS DETECTADAS! ğŸš¨ğŸš¨ğŸš¨", threats.len());
        println!("ğŸ’€ INICIANDO PROTOCOLO DE ELIMINAÃ‡ÃƒO - GOD MODE MAXIMUM\n");

        // Confirmar eliminaÃ§Ã£o
        print!("â“ ELIMINAR TODAS AS AMEAÃ‡AS? (s/N): ");
        io::stdout().flush()?;

        let mut input = String::new();
        io::stdin().read_line(&mut input)?;

        if input.trim().to_lowercase() == "s" {
            // Auto-eliminate threats
            if let Err(e) = hunter.eliminate_threats().await {
                eprintln!("âŒ ERRO NA ELIMINAÃ‡ÃƒO: {}", e);
            } else {
                println!("âœ… ELIMINAÃ‡ÃƒO CONCLUÃDA COM SUCESSO!");
            }
        } else {
            println!("âš ï¸ ELIMINAÃ‡ÃƒO CANCELADA - AMEAÃ‡AS PERMANECEM ATIVAS");
        }

        // Generate detailed report
        let report = hunter.generate_detailed_report();
        println!("\n{}", report);

        // Save report
        let report_path = "/Users/peluche/fenrir_malware_elimination_report.md";
        fs::write(report_path, report)?;
        println!("ğŸ“„ RELATÃ“RIO DETALHADO SALVO: {}", report_path);

        // Save JSON backup
        let json_backup = serde_json::to_string_pretty(&threats)?;
        let json_path = "/Users/peluche/fenrir_threats_backup.json";
        fs::write(json_path, json_backup)?;
        println!("ğŸ’¾ BACKUP JSON SALVO: {}", json_path);

    } else {
        println!("âœ… SISTEMA LIMPO - NENHUMA AMEAÃ‡A DETECTADA");
        println!("ğŸ›¡ï¸ FENRIR PROTECTION ATIVA - SISTEMA SEGURO");
    }

    println!("\nğŸº FENRIR GOD MODE - VIGILÃ‚NCIA PERMANENTE ATIVADA");
    Ok(())
}